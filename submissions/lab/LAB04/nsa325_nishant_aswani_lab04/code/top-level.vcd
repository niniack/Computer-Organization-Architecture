$date
	Wed Sep 25 00:27:51 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module top_level_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module tl $end
$var wire 32 # ALUin1 [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 $ testReg1 [31:0] $end
$var wire 32 % testReg2 [31:0] $end
$var wire 32 & SextOut [31:0] $end
$var wire 32 ' SLLOut [31:0] $end
$var wire 32 ( RFout2 [31:0] $end
$var wire 32 ) RFout1 [31:0] $end
$var wire 5 * RFWriteReg [4:0] $end
$var wire 32 + RFWriteData [31:0] $end
$var wire 32 , PCout [31:0] $end
$var wire 32 - PCnext [31:0] $end
$var wire 32 . IMout [31:0] $end
$var wire 32 / DMout [31:0] $end
$var wire 1 0 ALUzero $end
$var wire 32 1 ALUout [31:0] $end
$var wire 32 2 ALUin2 [31:0] $end
$var reg 4 3 ALUControl [3:0] $end
$var reg 1 4 ALUSrc $end
$var reg 1 5 MemtoReg $end
$var reg 32 6 PCin [31:0] $end
$var reg 1 7 RegDst $end
$var reg 1 8 RegWrite $end
$var reg 1 9 memRead $end
$var reg 1 : memWrite $end
$scope module alu $end
$var wire 1 ! clk $end
$var wire 4 ; funct [3:0] $end
$var wire 32 < inA [31:0] $end
$var wire 1 0 zero $end
$var wire 32 = inB [31:0] $end
$var reg 32 > out [31:0] $end
$upscope $end
$scope module alumux $end
$var wire 1 4 select $end
$var wire 32 ? out [31:0] $end
$var wire 32 @ inB [31:0] $end
$var wire 32 A inA [31:0] $end
$upscope $end
$scope module dm $end
$var wire 32 B address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 9 memRead $end
$var wire 1 : memWrite $end
$var wire 32 C writeData [31:0] $end
$var wire 32 D readData [31:0] $end
$upscope $end
$scope module im $end
$var wire 1 ! clk $end
$var wire 32 E readAddress [31:0] $end
$var reg 32 F instruction [31:0] $end
$upscope $end
$scope module immux $end
$var wire 5 G inA [4:0] $end
$var wire 5 H inB [4:0] $end
$var wire 1 7 select $end
$var wire 5 I out [4:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 32 J in [31:0] $end
$var wire 1 " rst $end
$var reg 32 K out [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 ! clk $end
$var wire 5 L readRegisterOne [4:0] $end
$var wire 5 M readRegisterTwo [4:0] $end
$var wire 1 " rst $end
$var wire 1 8 writeEnable $end
$var wire 5 N writeRegister [4:0] $end
$var wire 32 O writeData [31:0] $end
$var reg 32 P readDataOne [31:0] $end
$var reg 32 Q readDataTwo [31:0] $end
$var integer 32 R i [31:0] $end
$upscope $end
$scope module rfmux $end
$var wire 32 S inA [31:0] $end
$var wire 32 T inB [31:0] $end
$var wire 1 5 select $end
$var wire 32 U out [31:0] $end
$upscope $end
$scope module sext $end
$var wire 16 V in [15:0] $end
$var reg 32 W out [31:0] $end
$upscope $end
$scope module sll $end
$var wire 1 ! clk $end
$var wire 32 X in [31:0] $end
$var reg 32 Y out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Y
bx X
bx W
bx V
b0 U
b0 T
bx S
b11111 R
bx Q
bx P
b0 O
bx N
bx M
bx L
bx K
b0 J
bx I
bx H
bx G
bx F
bx E
b0 D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
b10 ;
0:
09
08
07
b0 6
15
14
b10 3
bx 2
bx 1
x0
b0 /
bx .
bx -
bx ,
b0 +
bx *
bx )
bx (
bx '
bx &
b0 %
b10111010101010101010101010101101 $
bx #
1"
0!
$end
#1
b100 -
b0 ,
b0 E
b0 K
b1 %
b11111 R
1!
#2
0!
#3
10
b0 1
b0 >
b0 B
b0 S
b0 '
b0 Y
b0 2
b0 =
b0 ?
b0 &
b0 @
b0 W
b0 X
b0 *
b0 I
b0 N
b0 (
b0 A
b0 C
b0 Q
b0 #
b0 <
b0 )
b0 P
b0 V
b0 M
b0 L
b0 H
b0 G
b1 %
b0 .
b0 F
b11111 R
1!
#4
0!
#5
b100 6
b100 J
1!
0"
#6
0!
#7
b1000 6
b1000 J
b1000 -
b100 ,
b100 E
b100 K
1!
#8
0!
#9
00
b1 1
b1 >
b1 B
b1 S
b1100 6
b1100 J
1:
b11011110101011011101111010101101 (
b11011110101011011101111010101101 A
b11011110101011011101111010101101 C
b11011110101011011101111010101101 Q
b1 #
b1 <
b1 )
b1 P
b1010 *
b1010 I
b1010 N
b1010 M
b1001 L
b1010 G
b1100 -
b1000 ,
b1000 E
b1000 K
b10101101001010100000000000000000 .
b10101101001010100000000000000000 F
1!
#10
0!
#11
b11011110101011011101111010101101 +
b11011110101011011101111010101101 O
b11011110101011011101111010101101 U
b11011110101011011101111010101101 /
b11011110101011011101111010101101 D
b11011110101011011101111010101101 T
19
0:
b10000 6
b10000 J
b1 (
b1 A
b1 C
b1 Q
b1001 *
b1001 I
b1001 N
b1001 M
b1001 G
18
b10001101001010010000000000000000 .
b10001101001010010000000000000000 F
b10000 -
b1100 ,
b1100 E
b1100 K
b11011110101011011101111010101101 $
1!
#12
0!
#13
bx00 '
bx00 Y
x0
b0 +
b0 O
b0 U
bx 2
bx =
bx ?
b0 /
b0 D
b0 T
bx &
bx @
bx W
bx X
bx 1
bx >
bx B
bx S
b10100 6
b10100 J
09
bx *
bx I
bx N
bx V
bx M
bx L
bx H
bx G
bx (
bx A
bx C
bx Q
bx #
bx <
bx )
bx P
b10100 -
b10000 ,
b10000 E
b10000 K
bx .
bx F
b11011110101011011101111010101101 %
1!
#14
0!
#15
b11000 6
b11000 J
b11000 -
b10100 ,
b10100 E
b10100 K
1!
#16
0!
#17
b11100 6
b11100 J
b11100 -
b11000 ,
b11000 E
b11000 K
1!
#18
0!
#19
b100000 6
b100000 J
b100000 -
b11100 ,
b11100 E
b11100 K
1!
#20
0!
#21
b100100 6
b100100 J
b100100 -
b100000 ,
b100000 E
b100000 K
1!
#22
0!
#23
b101000 6
b101000 J
b101000 -
b100100 ,
b100100 E
b100100 K
1!
#24
0!
#25
b101100 6
b101100 J
b101100 -
b101000 ,
b101000 E
b101000 K
1!
#26
0!
#27
b110000 6
b110000 J
b110000 -
b101100 ,
b101100 E
b101100 K
1!
#28
0!
#29
b110100 6
b110100 J
b110100 -
b110000 ,
b110000 E
b110000 K
1!
#30
0!
#31
b111000 6
b111000 J
b111000 -
b110100 ,
b110100 E
b110100 K
1!
#32
0!
#33
b111100 6
b111100 J
b111100 -
b111000 ,
b111000 E
b111000 K
1!
#34
0!
#35
b1000000 6
b1000000 J
b1000000 -
b111100 ,
b111100 E
b111100 K
1!
